----------------------------------------------------------------------------------------------------

do {
    a: = 1
    -- a
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

1

----------------------------------------------------------------------------------------------------

do {
    a:
    -- a
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Exception: Syntax error
<no file>, line 2
        a:
        ^^

----------------------------------------------------------------------------------------------------
# Infer return type from argument

+ foo(a) do {
    = a
}

do {
    -- foo(1)
    -- foo(1.5)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

1
1.500000

----------------------------------------------------------------------------------------------------
# Infer return type from type arguments

+ foo\T(t:Thing\T) do {
    = t.a
}

+ bar() do {
    = Thing\Double()
}

+ Thing\T {
    + a:T = 0
}

do {
    thing = bar()
    -- foo(thing)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

0.000000

----------------------------------------------------------------------------------------------------
# Infer return type with multiple returns of same type

+ foo(x) do {
    if (x > 1) {
        = 1
    } else {
        = 2
    }
}

do {
    -- foo(2)
    -- foo(0)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

1
2

----------------------------------------------------------------------------------------------------
# Infer return type with multiple returns of same type

+ foo(x) do {
    while (x > 1) {
        = 1
    }
    = 2
}

do {
    -- foo(2)
    -- foo(0)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

1
2

----------------------------------------------------------------------------------------------------
# Infer optional types from functions that do not always return

+ foo(x) do {
    if (x > 1) {
        = 1
    }
}

do {
    -- foo(1)
    -- foo(2)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

unknown
1

----------------------------------------------------------------------------------------------------
# Infer optional types from functions that do not always return

+ foo(x) do {
    if (x > 1) {
        = x
    }
}

do {
    -- foo(1)
    -- foo(2)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

unknown
2

----------------------------------------------------------------------------------------------------
# Infer union types from return values of different types

+ foo(x) do {
    if (x > 1) {
        = 1
    } else {
        = 2.5
    }
}

do {
    -- foo(2)
    -- foo(1)
}

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%nyi

1.000000
2.500000

----------------------------------------------------------------------------------------------------
